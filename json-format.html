<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSP Alignment Helper - Bid Request Formatter</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .param-header-row {
            display: grid;
            grid-template-columns: minmax(120px, 15%) minmax(150px, 30%) minmax(150px, 1fr);
            gap: 10px;
            padding: 10px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            font-size: 0.9em;
        }

        .param-row {
            display: grid;
            grid-template-columns: minmax(120px, 15%) minmax(150px, 30%) minmax(150px, 1fr);
            gap: 10px;
            padding: 6px 10px;
            border-bottom: 1px solid #eee;
            font-size: 0.85em;
        }

        .param-name {
            font-weight: 500;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .param-path {
            color: #666;
            font-family: monospace;
            font-size: 0.9em;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .param-value {
            font-family: monospace;
            font-size: 0.9em;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-all;
            white-space: pre-wrap;
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .different {
            background-color: #ffecb3;
        }

        .diff-row {
            background-color: #fffdf5;
        }

        .section-header {
            font-weight: bold;
            background-color: #eaeaea;
            padding: 5px 10px;
            margin-top: 10px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        /* Update for compare mode */
        .param-header-row.compare-mode {
            grid-template-columns: minmax(120px, 15%) minmax(150px, 20%) minmax(120px, 1fr) minmax(120px, 1fr);
        }

        .param-row.compare-mode {
            grid-template-columns: minmax(120px, 15%) minmax(150px, 20%) minmax(120px, 1fr) minmax(120px, 1fr);
        }

        .params-list {
            max-height: 600px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        .param-section {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1><a href="index.html" style="text-decoration: none; color: inherit;">XSP Alignment Helper</a></h1>
            <div class="view-switcher">
                <a href="index.html" class="view-link">Bidder View</a>
                <a href="publisher.html" class="view-link">Publisher View</a>
                <a href="endpoint.html" class="view-link">Endpoint View</a>
                <a href="opportunities.html" class="view-link">Opportunities</a>
                <div class="dropdown">
                    <a href="#" class="view-link active">Mike's Tools</a>
                    <div class="dropdown-content">
                        <a href="json-format.html">Bid Request Formatter</a>
                        <a href="app-ads-compliance.html">App-Ads Compliance</a>
                        <a href="md5-converter.html">MD5 Converter</a>
                        <a href="utc-converter.html">UTC Converter</a>
                        <a href="json-to-csv.html">JSON to CSV</a>
                    </div>
                </div>
            </div>
        </div>

        <h2>OpenRTB Bid Request Formatter and Parameter Analyzer</h2>
        
        <div class="json-tools">
            <div class="input-area">
                <div class="options-panel">
                    <div class="compare-toggle">
                        <input type="checkbox" id="compareCheckbox" class="toggle-checkbox">
                        <label for="compareCheckbox">Compare Requests</label>
                    </div>
                </div>
                <label for="jsonInput">Input JSON (paste OpenRTB bid request):</label>
                <textarea id="jsonInput" rows="15" placeholder="Paste your JSON here..."></textarea>
                
                <div id="secondInputContainer" style="display: none; margin-top: 20px;">
                    <label for="jsonInput2">Second JSON (paste another OpenRTB bid request to compare):</label>
                    <textarea id="jsonInput2" rows="15" placeholder="Paste second JSON for comparison..."></textarea>
                </div>
            </div>
            
            <div class="button-group">
                <button id="compareBtn" class="button" style="display: none;">Compare</button>
                <button id="clearBtn" class="button">Clear</button>
            </div>
            
            <div class="output-area">
                <label for="jsonOutput">Formatted JSON:</label>
                <div id="sideByContainer" style="display: none; gap: 20px;">
                    <div class="json-column">
                        <h4>Request 1</h4>
                        <textarea id="jsonOutput1" rows="15" readonly></textarea>
                    </div>
                    <div class="json-column">
                        <h4>Request 2</h4>
                        <textarea id="jsonOutput2" rows="15" readonly></textarea>
                    </div>
                </div>
                <textarea id="jsonOutput" rows="15" readonly></textarea>
                <div id="validationResult"></div>
            </div>
            
            <div id="comparisonOutput" style="display: none; margin-top: 20px;">
                <h3>Comparison Results</h3>
                <div class="comparison-container">
                    <div class="comparison-column">
                        <h4>Request 1 Unique Parameters</h4>
                        <div id="request1Unique" class="comparison-list"></div>
                    </div>
                    <div class="comparison-column">
                        <h4>Request 2 Unique Parameters</h4>
                        <div id="request2Unique" class="comparison-list"></div>
                    </div>
                </div>
            </div>
            
            <div class="params-area">
                <div class="params-header">
                    <label for="paramsOutput">Parameters List:</label>
                    <div class="specs-link">
                        <a href="https://github.com/InteractiveAdvertisingBureau/openrtb2.x/blob/main/2.6.md" target="_blank">
                            OpenRTB Spec Reference
                        </a>
                    </div>
                </div>
                <div id="paramsOutput" class="params-list"></div>
            </div>
        </div>
    </div>

    <a href="#" class="scroll-top" id="scrollTop">â†‘</a>

    <script>
        // Auto-format JSON when text is entered/pasted
        document.getElementById('jsonInput').addEventListener('input', formatJSON);
        document.getElementById('jsonInput').addEventListener('paste', function() {
            // Using setTimeout to get the pasted content after the paste event
            setTimeout(formatJSON, 10);
        });
        
        // Toggle second input area when checkbox is checked
        document.getElementById('compareCheckbox').addEventListener('change', function() {
            const secondInputContainer = document.getElementById('secondInputContainer');
            const compareBtn = document.getElementById('compareBtn');
            const comparisonOutput = document.getElementById('comparisonOutput');
            const sideByContainer = document.getElementById('sideByContainer');
            const singleOutput = document.getElementById('jsonOutput');
            
            if (this.checked) {
                secondInputContainer.style.display = 'block';
                compareBtn.style.display = 'inline-block';
                sideByContainer.style.display = 'flex';
                singleOutput.style.display = 'none';
                // Clear and update the formatting when entering comparison mode
                if (document.getElementById('jsonInput').value) {
                    formatJSON();
                }
            } else {
                secondInputContainer.style.display = 'none';
                compareBtn.style.display = 'none';
                comparisonOutput.style.display = 'none';
                sideByContainer.style.display = 'none';
                singleOutput.style.display = 'block';
                // Restore single view format
                formatJSON();
            }
        });
        
        // Handle compare button click
        document.getElementById('compareBtn').addEventListener('click', compareJsonRequests);
        
        function compareJsonRequests() {
            const input1 = document.getElementById('jsonInput').value;
            const input2 = document.getElementById('jsonInput2').value;
            const request1Unique = document.getElementById('request1Unique');
            const request2Unique = document.getElementById('request2Unique');
            const comparisonOutput = document.getElementById('comparisonOutput');
            
            if (!input1.trim() || !input2.trim()) {
                alert('Please enter both JSON requests for comparison');
                return;
            }
            
            try {
                // Parse both inputs
                const parsed1 = JSON.parse(input1);
                const parsed2 = JSON.parse(input2);
                
                // Extract parameters from both requests
                const paths1 = collectPaths(parsed1);
                const paths2 = collectPaths(parsed2);
                
                // Find unique parameters
                const unique1 = paths1.filter(path => !paths2.includes(path));
                const unique2 = paths2.filter(path => !paths1.includes(path));
                
                // Group paths by their parent structure
                const grouped1 = groupPathsByStructure(unique1);
                const grouped2 = groupPathsByStructure(unique2);
                
                // Display results
                request1Unique.innerHTML = '';
                request2Unique.innerHTML = '';
                
                if (unique1.length === 0) {
                    request1Unique.innerHTML = '<p class="no-params">No unique parameters</p>';
                } else {
                    displayGroupedPaths(grouped1, request1Unique, parsed1);
                }
                
                if (unique2.length === 0) {
                    request2Unique.innerHTML = '<p class="no-params">No unique parameters</p>';
                } else {
                    displayGroupedPaths(grouped2, request2Unique, parsed2);
                }
                
                // Show comparison output
                comparisonOutput.style.display = 'block';
                
                // Also update the formatting for side-by-side view
                formatJSON();
                
            } catch (error) {
                alert(`Error comparing JSON: ${error.message}`);
            }
        }
        
        // Function to collect all parameter paths in a JSON object
        function collectPaths(obj, path = '', result = []) {
            if (obj === null || obj === undefined) return result;
            
            if (Array.isArray(obj)) {
                // For arrays, we just consider their existence, not each element
                if (path) result.push(path);
                
                // Process first item as representative if it's an object
                if (obj.length > 0 && typeof obj[0] === 'object' && obj[0] !== null) {
                    collectPaths(obj[0], path ? `${path}[]` : '[]', result);
                }
            } else if (typeof obj === 'object') {
                // For objects
                if (path) result.push(path);
                
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        const newPath = path ? `${path}.${key}` : key;
                        const value = obj[key];
                        
                        result.push(newPath);
                        
                        // Recurse into object/array values
                        if (typeof value === 'object' && value !== null) {
                            collectPaths(value, newPath, result);
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Function to group paths by their parent structure
        function groupPathsByStructure(paths) {
            const grouped = {};
            
            paths.forEach(path => {
                const parts = path.split('.');
                let structureName;
                
                if (parts.length === 1) {
                    structureName = 'top';
                } else {
                    structureName = parts[0];
                }
                
                if (!grouped[structureName]) {
                    grouped[structureName] = [];
                }
                
                grouped[structureName].push(path);
            });
            
            return grouped;
        }
        
        // Function to get value from JSON object using path string
        function getValueFromPath(obj, path) {
            if (!path) return undefined;
            
            // Handle array notation like item[] or item[0]
            path = path.replace(/\[\d*\]/g, '[0]');
            
            const parts = path.split('.');
            let current = obj;
            
            for (const part of parts) {
                if (part.includes('[')) {
                    // Handle array access
                    const arrPart = part.split('[')[0];
                    if (!current[arrPart] || !Array.isArray(current[arrPart]) || current[arrPart].length === 0) {
                        return undefined;
                    }
                    current = current[arrPart][0];
                } else {
                    if (current === undefined || current === null) {
                        return undefined;
                    }
                    current = current[part];
                }
            }
            
            return current;
        }
        
        // Function to format value for display
        function formatValueForDisplay(value) {
            if (value === undefined) return 'undefined';
            if (value === null) return 'null';
            
            if (typeof value === 'object') {
                if (Array.isArray(value)) {
                    if (value.length === 0) return '[]';
                    if (value.length > 3) return `[Array(${value.length})]`;
                    return JSON.stringify(value).substring(0, 50) + (JSON.stringify(value).length > 50 ? '...' : '');
                }
                return '{Object}';
            }
            
            if (typeof value === 'string') {
                return `"${value.substring(0, 50)}${value.length > 50 ? '...' : ''}"`;
            }
            
            return String(value);
        }
        
        // Function to display grouped paths with values
        function displayGroupedPaths(grouped, container, jsonObj) {
            for (const [structure, paths] of Object.entries(grouped)) {
                const structureDiv = document.createElement('div');
                structureDiv.className = 'comparison-structure';
                
                const header = document.createElement('h5');
                header.textContent = structure === 'top' ? 'Top Level' : structure;
                structureDiv.appendChild(header);
                
                const list = document.createElement('ul');
                list.className = 'comparison-path-list';
                
                paths.sort().forEach(path => {
                    const item = document.createElement('li');
                    item.className = 'comparison-path-item';
                    
                    // Get value for this path
                    const value = getValueFromPath(jsonObj, path);
                    const formattedValue = formatValueForDisplay(value);
                    
                    item.textContent = `${path}: ${formattedValue}`;
                    
                    // Add tooltip if description exists for the leaf parameter
                    const paramName = path.split('.').pop().replace('[]', '');
                    if (rtbDescriptions[paramName]) {
                        item.title = rtbDescriptions[paramName];
                        item.classList.add('has-tooltip');
                    }
                    
                    list.appendChild(item);
                });
                
                structureDiv.appendChild(list);
                container.appendChild(structureDiv);
            }
        }
        
        function formatJSON() {
            const input1 = document.getElementById('jsonInput').value;
            const outputSingle = document.getElementById('jsonOutput');
            const output1 = document.getElementById('jsonOutput1');
            const output2 = document.getElementById('jsonOutput2');
            const validationResult = document.getElementById('validationResult');
            const paramsOutput = document.getElementById('paramsOutput');
            const isCompareMode = document.getElementById('compareCheckbox').checked;
            const input2 = isCompareMode ? document.getElementById('jsonInput2').value : '';
            
            // Clear displays
            outputSingle.value = '';
            output1.value = '';
            output2.value = '';
            validationResult.textContent = '';
            validationResult.className = '';
            paramsOutput.innerHTML = '';
            
            if (!input1.trim() && (!isCompareMode || !input2.trim())) {
                return;
            }
            
            try {
                // Parse first input
                let parsedJson1 = null;
                let parsedJson2 = null;
                let structuredParams1 = null;
                let structuredParams2 = null;
                let formattedJson1 = '';
                let formattedJson2 = '';
                let isValid = true;
                
                if (input1.trim()) {
                    parsedJson1 = JSON.parse(input1);
                    formattedJson1 = JSON.stringify(parsedJson1, null, 2);
                    structuredParams1 = extractStructuredParams(parsedJson1, true);
                }
                
                // If in compare mode, parse second input
                if (isCompareMode && input2.trim()) {
                    parsedJson2 = JSON.parse(input2);
                    formattedJson2 = JSON.stringify(parsedJson2, null, 2);
                    structuredParams2 = extractStructuredParams(parsedJson2, true);
                }
                
                // Display formatted JSON
                if (isCompareMode && parsedJson1 && parsedJson2) {
                    // Display in separate columns
                    output1.value = formattedJson1;
                    output2.value = formattedJson2;
                    
                    validationResult.textContent = 'Both JSONs are valid';
                    validationResult.className = 'valid';
                    
                    // Merge parameters for display
                    const mergedParams = mergeStructuredParams(structuredParams1, structuredParams2);
                    displayStructuredParams(mergedParams, paramsOutput, parsedJson1, parsedJson2);
                    
                } else if (parsedJson1) {
                    // Just display the first/only JSON in the single output
                    outputSingle.value = formattedJson1;
                    validationResult.textContent = 'JSON is valid';
                    validationResult.className = 'valid';
                    
                    // Display parameters
                    displayStructuredParams(structuredParams1, paramsOutput, parsedJson1);
                }
                
            } catch (error) {
                outputSingle.value = '';
                output1.value = '';
                output2.value = '';
                validationResult.textContent = `Invalid JSON: ${error.message}`;
                validationResult.className = 'invalid';
                paramsOutput.innerHTML = '';
            }
        }
        
        document.getElementById('clearBtn').addEventListener('click', function() {
            document.getElementById('jsonInput').value = '';
            document.getElementById('jsonInput2').value = '';
            document.getElementById('jsonOutput').value = '';
            document.getElementById('jsonOutput1').value = '';
            document.getElementById('jsonOutput2').value = '';
            document.getElementById('validationResult').textContent = '';
            document.getElementById('paramsOutput').innerHTML = '';
            document.getElementById('comparisonOutput').style.display = 'none';
        });
        
        // RTB parameter descriptions
        const rtbDescriptions = {
            // Top level
            "id": "Unique ID of the bid request",
            "imp": "Array of Impression objects representing the impressions offered",
            "site": "Details about the publisher's website",
            "app": "Details about the publisher's app",
            "device": "Details about the user's device",
            "user": "Details about the user",
            "test": "Flag to indicate if bid request is a test",
            "at": "Auction type (1=first price, 2=second price)",
            "tmax": "Maximum time in milliseconds for bids to be received",
            "wseat": "Array of buyer seats allowed to bid",
            "bseat": "Array of buyer seats blocked from bidding",
            "allimps": "Flag to indicate if all impressions are being offered",
            "cur": "Array of allowed currencies",
            "wlang": "Array of allowed languages",
            "bcat": "Array of blocked advertiser categories",
            "badv": "Array of blocked advertiser domains",
            "bapp": "Array of blocked applications",
            "source": "Source of the impression opportunity",
            "regs": "Regulatory restrictions",
            
            // Imp object
            "secure": "Flag to indicate if impression requires HTTPS",
            "bidfloor": "Minimum bid for this impression in CPM",
            "bidfloorcur": "Currency of the bidfloor",
            "pmp": "Private marketplace object containing deals",
            "displaymanager": "Name of ad mediation partner, SDK, or player",
            "displaymanagerver": "Version of ad mediation partner, SDK, or player",
            "instl": "Flag to indicate if impression is interstitial",
            "tagid": "Identifier for specific ad placement or ad tag",
            "clickbrowser": "Flag to indicate if click will launch browser",
            "exp": "Advisory duration of the impression availability in seconds",
            "metric": "Array of metric objects for this impression",
            
            // Banner object
            "w": "Width of the creative in pixels",
            "h": "Height of the creative in pixels",
            "format": "Array of banner format objects",
            "pos": "Ad position (0=unknown, 1=above fold, 3=below fold)",
            "api": "List of supported API frameworks",
            "id": "Unique identifier for this banner object",
            
            // Video object
            "mimes": "Array of supported MIME types",
            "minduration": "Minimum video ad duration in seconds",
            "maxduration": "Maximum video ad duration in seconds",
            "protocols": "Array of supported video protocols",
            "startdelay": "Start delay in seconds for pre/mid/post-roll ads",
            "placement": "Video placement type",
            "linearity": "Indicates if the ad must be linear, nonlinear, etc",
            
            // Audio object
            "sequence": "If multiple ads, the sequence number",
            "battr": "Blocked creative attributes",
            "maxextended": "Maximum extended ad duration",
            "minbitrate": "Minimum bit rate in Kbps",
            "maxbitrate": "Maximum bit rate in Kbps",
            
            // Native object
            "request": "Native request object or string",
            "ver": "Native specification version",
            "api": "List of supported API frameworks",
            "battr": "Blocked creative attributes",
            
            // App object
            "name": "App name",
            "bundle": "App bundle or package name",
            "domain": "Domain of the app",
            "storeurl": "App store URL",
            "cat": "Array of IAB content categories",
            "sectioncat": "Array of IAB content categories for this section",
            "pagecat": "Array of IAB content categories for this page",
            "ver": "App version",
            "privacypolicy": "Flag to indicate if app has a privacy policy",
            "paid": "Flag to indicate if this is a paid app",
            "publisher": "Publisher object",
            "content": "Content object",
            "keywords": "Comma separated list of keywords",
            
            // Device object
            "ua": "User agent",
            "geo": "Geo object",
            "dnt": "Do Not Track flag",
            "lmt": "Limit Ad Tracking flag",
            "ip": "IP address",
            "ipv6": "IPv6 address",
            "devicetype": "Device type",
            "make": "Device make",
            "model": "Device model",
            "os": "Operating system",
            "osv": "Operating system version",
            "hwv": "Hardware version",
            "h": "Physical height of the screen in pixels",
            "w": "Physical width of the screen in pixels",
            "ppi": "Screen size as pixels per linear inch",
            "pxratio": "Ratio of physical pixels to device independent pixels",
            "js": "Support for JavaScript",
            "language": "Browser language",
            "carrier": "Carrier or ISP",
            "connectiontype": "Network connection type",
            "ifa": "ID sanctioned for advertiser use",
            
            // User object
            "buyeruid": "Buyer-specific ID for the user",
            "yob": "Year of birth as a 4-digit integer",
            "gender": "Gender (M=male, F=female, O=other)",
            "keywords": "Comma separated list of keywords, interests, or intent",
            "customdata": "Optional feature to pass bidder data",
            "geo": "Location of the user's home base",
            "data": "Additional user targeting data",
            "eids": "Extended identifiers array",
            
            // Source object
            "fd": "Buyer-specific fee that should be disclosed to the user",
            "tid": "Transaction ID",
            "pchain": "Payment ID chain string",
            "schain": "Supply chain object"
        };
        
        // Function to extract parameters organized by their parent objects
        function extractStructuredParams(obj, includeValues = false) {
            const result = {};
            
            function addParam(section, path) {
                if (!result[section]) {
                    result[section] = [];
                }
                result[section].push({ path });
            }
            
            function traverse(obj, path = '', depth = 0) {
                if (obj === null || obj === undefined) return;
                
                if (depth === 0) {
                    // Top level parameters
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            addParam('top', key);
                            
                            // Recurse into object/array values
                            if (typeof obj[key] === 'object' && obj[key] !== null) {
                                traverse(obj[key], key, depth + 1);
                            }
                        }
                    }
                } else if (Array.isArray(obj)) {
                    // For arrays, process the first element as representative
                    if (obj.length > 0) {
                        const newPath = `${path}[0]`;
                        if (typeof obj[0] === 'object' && obj[0] !== null) {
                            traverse(obj[0], newPath, depth + 1);
                        } else {
                            // Simple array value
                            const sectionName = path.split('.')[0];
                            addParam(sectionName, newPath);
                        }
                    } else {
                        // Empty array
                        const sectionName = path.split('.')[0];
                        addParam(sectionName, path);
                    }
                } else if (typeof obj === 'object') {
                    // For objects
                    const sectionName = path.split('.')[0];
                    
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            const newPath = `${path}.${key}`;
                            addParam(sectionName, newPath);
                            
                            // Recurse into object/array values
                            if (typeof obj[key] === 'object' && obj[key] !== null) {
                                traverse(obj[key], newPath, depth + 1);
                            }
                        }
                    }
                }
            }
            
            traverse(obj);
            
            // Sort parameters within each section
            for (const section in result) {
                result[section].sort((a, b) => a.path.localeCompare(b.path));
            }
            
            return result;
        }
        
        // Function to display structured parameters
        function displayStructuredParams(structuredParams, container, jsonObj1, jsonObj2 = null) {
            container.innerHTML = '';
            
            const isCompareMode = !!jsonObj2;
            
            // Create header row for parameters
            const headerRow = document.createElement('div');
            headerRow.className = isCompareMode ? 'param-header-row compare-mode' : 'param-header-row';
            
            if (isCompareMode) {
                headerRow.innerHTML = `
                    <div class="param-name">Parameter</div>
                    <div class="param-path">Path</div>
                    <div class="param-value">Value (Request 1)</div>
                    <div class="param-value">Value (Request 2)</div>
                `;
            } else {
                headerRow.innerHTML = `
                    <div class="param-name">Parameter</div>
                    <div class="param-path">Path</div>
                    <div class="param-value">Value</div>
                `;
            }
            
            container.appendChild(headerRow);
            
            // Guard against undefined or empty structuredParams
            if (!structuredParams) {
                return;
            }
            
            for (const section in structuredParams) {
                if (!structuredParams[section] || !Array.isArray(structuredParams[section])) {
                    continue;
                }
                
                const sectionElement = document.createElement('div');
                sectionElement.className = 'param-section';
                
                const sectionHeader = document.createElement('div');
                sectionHeader.className = 'section-header';
                sectionHeader.textContent = section === 'top' ? 'Top Level' : section;
                sectionElement.appendChild(sectionHeader);
                
                for (const param of structuredParams[section]) {
                    // Guard against undefined param or param.path
                    if (!param || !param.path) {
                        continue;
                    }
                    
                    const paramRow = document.createElement('div');
                    paramRow.className = isCompareMode ? 'param-row compare-mode' : 'param-row';
                    
                    const paramNameElement = document.createElement('div');
                    paramNameElement.className = 'param-name';
                    const paramParts = param.path.split('.');
                    const paramName = paramParts.length > 0 ? 
                        paramParts[paramParts.length - 1].replace(/\[\d*\]/, '') : 
                        param.path;
                    
                    paramNameElement.textContent = paramName;
                    
                    // Add tooltip if description exists
                    if (rtbDescriptions[paramName]) {
                        paramNameElement.title = rtbDescriptions[paramName];
                        paramNameElement.classList.add('has-tooltip');
                    }
                    
                    const paramPathElement = document.createElement('div');
                    paramPathElement.className = 'param-path';
                    paramPathElement.textContent = param.path;
                    
                    paramRow.appendChild(paramNameElement);
                    paramRow.appendChild(paramPathElement);
                    
                    if (isCompareMode) {
                        // Get values from both JSONs
                        const value1 = getValueByPath(jsonObj1, param.path);
                        const value2 = getValueByPath(jsonObj2, param.path);
                        const isDifferent = !isValueEqual(value1, value2);
                        
                        const paramValue1Element = document.createElement('div');
                        paramValue1Element.className = 'param-value' + (isDifferent ? ' different' : '');
                        paramValue1Element.textContent = formatValue(value1);
                        
                        const paramValue2Element = document.createElement('div');
                        paramValue2Element.className = 'param-value' + (isDifferent ? ' different' : '');
                        paramValue2Element.textContent = formatValue(value2);
                        
                        paramRow.appendChild(paramValue1Element);
                        paramRow.appendChild(paramValue2Element);
                        
                        if (isDifferent) {
                            paramRow.classList.add('diff-row');
                        }
                    } else {
                        // Just one JSON
                        const paramValueElement = document.createElement('div');
                        paramValueElement.className = 'param-value';
                        paramValueElement.textContent = formatValue(getValueByPath(jsonObj1, param.path));
                        paramRow.appendChild(paramValueElement);
                    }
                    
                    sectionElement.appendChild(paramRow);
                }
                
                container.appendChild(sectionElement);
            }
        }
        
        // Helper function to get a value from JSON using a path string
        function getValueByPath(obj, path) {
            if (!obj) return undefined;
            
            try {
                // Handle array paths like item[0].property
                const parts = path.split('.');
                let current = obj;
                
                for (const part of parts) {
                    if (part.includes('[') && part.includes(']')) {
                        const name = part.substring(0, part.indexOf('['));
                        const index = parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));
                        
                        if (!current[name] || !Array.isArray(current[name]) || index >= current[name].length) {
                            return undefined;
                        }
                        
                        current = current[name][isNaN(index) ? 0 : index];
                    } else {
                        if (current === undefined || current === null) {
                            return undefined;
                        }
                        current = current[part];
                    }
                }
                
                return current;
            } catch (e) {
                return undefined;
            }
        }
        
        // Helper function to format a value for display
        function formatValue(value) {
            if (value === undefined) return 'â€”';
            if (value === null) return 'null';
            
            if (typeof value === 'object') {
                if (Array.isArray(value)) {
                    if (value.length === 0) return '[]';
                    if (typeof value[0] === 'object' && value[0] !== null) {
                        return `[Array of ${value.length} objects]`;
                    }
                    return JSON.stringify(value);
                }
                return JSON.stringify(value);
            }
            
            return String(value);
        }
        
        // Helper function to compare values
        function isValueEqual(val1, val2) {
            if (val1 === val2) return true;
            if (val1 === undefined && val2 === undefined) return true;
            if (val1 === null && val2 === null) return true;
            
            // If both are objects/arrays
            if (typeof val1 === 'object' && typeof val2 === 'object' && val1 !== null && val2 !== null) {
                return JSON.stringify(val1) === JSON.stringify(val2);
            }
            
            return false;
        }
        
        // Function to merge parameter structures from two requests
        function mergeStructuredParams(params1, params2) {
            if (!params1) return params2;
            if (!params2) return params1;
            
            const result = {};
            
            // Add all sections and parameters from params1
            for (const section in params1) {
                result[section] = [...params1[section]];
            }
            
            // Add or merge sections from params2
            for (const section in params2) {
                if (!result[section]) {
                    result[section] = [...params2[section]];
                } else {
                    // Add params from params2 that aren't in result already
                    const existingPaths = new Set(result[section].map(p => p.path));
                    
                    for (const param of params2[section]) {
                        if (!existingPaths.has(param.path)) {
                            result[section].push(param);
                        }
                    }
                    
                    // Re-sort
                    result[section].sort((a, b) => a.path.localeCompare(b.path));
                }
            }
            
            return result;
        }
        
        // Scroll-to-top functionality
        document.addEventListener('DOMContentLoaded', function() {
            const scrollButton = document.getElementById('scrollTop');
            
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 300) {
                    scrollButton.classList.add('visible');
                } else {
                    scrollButton.classList.remove('visible');
                }
            });

            scrollButton.addEventListener('click', function(e) {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
    </script>
</body>
</html>
